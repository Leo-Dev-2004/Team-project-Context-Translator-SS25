from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from Backend.QueueManager.shared_queue import (
    to_frontend_queue,
    from_frontend_queue,
    to_backend_queue,
    from_backend_queue
)
import asyncio
import json
import logging

app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# WebSocket endpoint
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    # Start background tasks for queue processing
    sender_task = asyncio.create_task(send_messages(websocket))
    receiver_task = asyncio.create_task(receive_messages(websocket))
    
    try:
        await asyncio.gather(sender_task, receiver_task)
    except Exception as e:
        logging.error(f"WebSocket error: {e}")
    finally:
        sender_task.cancel()
        receiver_task.cancel()

async def send_messages(websocket: WebSocket):
    """Send messages from to_frontend_queue to client"""
    while True:
        message = to_frontend_queue.dequeue(timeout=1.0)
        if message:
            try:
                await websocket.send_text(json.dumps(message))
            except Exception as e:
                logging.error(f"Failed to send message: {e}")
                from_frontend_queue.enqueue(message)  # Requeue if failed
        await asyncio.sleep(0.1)  # Prevent busy waiting

async def receive_messages(websocket: WebSocket):
    """Receive messages from client and add to from_frontend_queue"""
    while True:
        try:
            data = await websocket.receive_text()
            message = json.loads(data)
            from_frontend_queue.enqueue(message)
        except Exception as e:
            logging.error(f"Failed to process message: {e}")
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from Backend.QueueManager.shared_queue import (
    to_frontend_queue,
    from_frontend_queue,
    to_backend_queue,
    from_backend_queue
)
import asyncio
import json
import logging

app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# WebSocket endpoint
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    # Start background tasks for queue processing
    sender_task = asyncio.create_task(send_messages(websocket))
    receiver_task = asyncio.create_task(receive_messages(websocket))
    
    try:
        await asyncio.gather(sender_task, receiver_task)
    except Exception as e:
        logging.error(f"WebSocket error: {e}")
    finally:
        sender_task.cancel()
        receiver_task.cancel()

async def send_messages(websocket: WebSocket):
    """Send messages from to_frontend_queue to client"""
    while True:
        message = to_frontend_queue.dequeue(timeout=1.0)
        if message:
            try:
                await websocket.send_text(json.dumps(message))
            except Exception as e:
                logging.error(f"Failed to send message: {e}")
                from_frontend_queue.enqueue(message)  # Requeue if failed
        await asyncio.sleep(0.1)  # Prevent busy waiting

async def receive_messages(websocket: WebSocket):
    """Receive messages from client and add to from_frontend_queue"""
    while True:
        try:
            data = await websocket.receive_text()
            message = json.loads(data)
            from_frontend_queue.enqueue(message)
        except Exception as e:
            logging.error(f"Failed to process message: {e}")

// HTTP Server für Initial Handshake
const server = http.createServer((req, res) => {
  // Hier könnte Logik für initiale HTTP Anfragen sein (z.B. Validierung vor WebSocket-Upgrade)
  // Das Diagramm zeigt einen HTTP/1.1 101 Switching Protocols Request
});

// WebSocket Server auf dem HTTP Server aufsetzen
const wss = new WebSocket.Server({ server });

// Handler für neue WebSocket Verbindungen
wss.on('connection', (ws, req) => {
  // Initial Handshake & Validierung (JWT Token)
  // Prüfe Header (Upgrade: websocket, Connection: Upgrade, Authorization: Bearer <JWT>)
  const token = req.headers['authorization']?.split(' ')[1];
  if (!validateToken(token)) { // validateToken wäre eine eigene Funktion
    ws.send(JSON.stringify({ type: 'error', message: 'Authentication failed' }));
    ws.close(1008, 'Authentication failed'); // WebSocket Close Code 1008 (Policy Violation)
    return;
  }

  // Verbindung ist etabliert und validiert
  console.log('Client verbunden');

  // Event Listener für Nachrichten vom Frontend
  ws.on('message', (message) => {
    // Nachrichten können Audio-Daten (OPUS/RTP), Steuerbefehle oder andere Daten sein 
    handleFrontendMessage(ws, message);
  });

  // Event Listener für geschlossene Verbindung
  ws.on('close', () => {
    console.log('Client getrennt');
    // Bereinigung: Queues leeren, Benutzer-Status aktualisieren etc.
  });

  // Event Listener für Fehler
  ws.on('error', (error) => {
    console.error('WebSocket Fehler:', error);
    // Fehlerbehandlung
  });

  // Sende Bestätigung oder initiale Daten ans Frontend
  ws.send(JSON.stringify({ type: 'connected', status: 'authenticated' }));
});

// Funktion zur Verarbeitung von Nachrichten vom Frontend
function handleFrontendMessage(ws, message) {
  // Nachricht parsen (wenn nicht reines Audio)
  // const data = JSON.parse(message);

  // Unterscheide nach Nachrichtentyp (Audio, Kommando, etc.)
  // Beispiel: Wenn Nachricht Audio ist:
  if (isAudioData(message)) { // isAudioData wäre eine eigene Prüffunktion
    // Audio-Daten in interne Queue legen oder direkt verarbeiten
    processAudioStream(ws, message);
  } else {
    // Andere Nachrichtentypen verarbeiten (z.B. Benutzeraktionen)
    handleControlMessage(ws, message);
  }
}

// Funktion zur Verarbeitung des Audio-Streams
async function processAudioStream(ws, audioChunk) {
  // Audio-Chunk (OPUS/RTP) entgegennehmen
  // Ggf. Audio-Daten sammeln/puffern, bis genügend für STT vorhanden ist
  // Zum STT-Modul schicken
  // const transcript = await stt.process(audioChunk); // Beispiel: Aufruf STT Modul

  // Transkript verarbeiten (z.B. in Transkript-Queue legen, an Frontend schicken)
  // checkAndGenerateExplanations(transcript); // Prüfe auf erklärungsbedürftige Wörter
}

// Funktion zur Verarbeitung von Steuerbefehlen
function handleControlMessage(ws, message) {
  // Logik für Befehle wie: Meeting starten/beitreten, Mikrofon stummschalten, etc.
  // Beispiel:
  // if (message.type === 'joinMeeting') { ... }
}

// Funktion zur Überprüfung und Generierung von Erklärungen
async function checkAndGenerateExplanations(transcriptSnippet) {
  // Analysiere Transkript-Snippet auf erklärungsbedürftige Wörter
  // Hole relevanten Meeting-Kontext & Benutzer-Domänen aus der DB
  // const context = await db.getMeetingContext(...);
  // const userDomains = await db.getActiveUserDomains(...);

  // Sende relevante Daten an das LLM zur Erklärung
  // const explanation = await llm.generateExplanation(transcriptSnippet, context, userDomains); // Beispiel: Aufruf LLM Modul

  // Erklärung ans Frontend schicken (über FromFrontendQueue)
  // sendExplanationToFrontend(explanation);
}

// Funktion zum Senden von Daten ans Frontend
function sendToFrontend(ws, data) {
  // Daten in FromFrontendQueue legen
  // Queue verarbeiten und Daten über WebSocket senden
  ws.send(JSON.stringify(data));
}

// Hilfsfunktion zur Validierung des JWT Tokens
function validateToken(token) {
  // Logik zur JWT Validierung (Signatur prüfen, Ablaufdatum, etc.)
  return true; // Platzhalter
}


// Server starten
const PORT = process.env.PORT || 8080;
server.listen(PORT, () => {
  console.log(`Backend Server läuft auf Port ${PORT}`);
});
